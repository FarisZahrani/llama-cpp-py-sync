name: Build Wheels

on:
  push:
    tags: ['*']
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force rebuild even if no upstream changes'
        required: false
        default: 'false'

env:
  LLAMA_CPP_REPO: https://github.com/ggerganov/llama.cpp.git

jobs:
  check-upstream:
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.check.outputs.should_build }}
      upstream_sha: ${{ steps.check.outputs.upstream_sha }}
      upstream_tag: ${{ steps.check.outputs.upstream_tag }}
      upstream_tag_exists: ${{ steps.check.outputs.upstream_tag_exists }}
      latest_upstream_tag: ${{ steps.check.outputs.latest_upstream_tag }}
      latest_upstream_tag_sha: ${{ steps.check.outputs.latest_upstream_tag_sha }}
    steps:
      - uses: actions/checkout@v4

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
      
      - name: Check upstream for changes
        id: check
        run: |
          EVENT_NAME="${{ github.event_name }}"
          REF_TYPE="${{ github.ref_type }}"
          REF_NAME="${{ github.ref_name }}"

          # If this workflow is running for a tag, prefer building against the upstream tag SHA *if it exists upstream*.
          # Otherwise, build against upstream HEAD.
          UPSTREAM_TAG=""
          UPSTREAM_TAG_EXISTS="false"

          if [ "${REF_TYPE}" = "tag" ] && [ -n "${REF_NAME}" ]; then
            UPSTREAM_TAG="${REF_NAME}"
            UPSTREAM_SHA=$(git ls-remote --tags --refs ${{ env.LLAMA_CPP_REPO }} "refs/tags/${UPSTREAM_TAG}" | cut -f1)
            if [ -n "${UPSTREAM_SHA}" ]; then
              UPSTREAM_TAG_EXISTS="true"
            else
              # Local-only tag; don't publish a Release/PyPI for it.
              UPSTREAM_SHA=$(git ls-remote ${{ env.LLAMA_CPP_REPO }} HEAD | cut -f1)
            fi
          else
            UPSTREAM_SHA=$(git ls-remote ${{ env.LLAMA_CPP_REPO }} HEAD | cut -f1)
          fi

          echo "upstream_tag=${UPSTREAM_TAG}" >> $GITHUB_OUTPUT
          echo "upstream_tag_exists=${UPSTREAM_TAG_EXISTS}" >> $GITHUB_OUTPUT

          echo "upstream_sha=${UPSTREAM_SHA}" >> $GITHUB_OUTPUT

          # Discover latest upstream tag (for scheduled mirroring).
          # Uses version-sort; works well for semver tags (v1.2.3) and most tag naming schemes.
          LATEST_UPSTREAM_TAG=$(git ls-remote --tags --refs ${{ env.LLAMA_CPP_REPO }} 'refs/tags/*' |
            awk -F/ '{print $NF}' |
            sort -V |
            tail -n 1)

          if [ -n "${LATEST_UPSTREAM_TAG}" ]; then
            LATEST_UPSTREAM_TAG_SHA=$(git ls-remote --tags --refs ${{ env.LLAMA_CPP_REPO }} "refs/tags/${LATEST_UPSTREAM_TAG}" | cut -f1)
          else
            LATEST_UPSTREAM_TAG_SHA=""
          fi

          echo "latest_upstream_tag=${LATEST_UPSTREAM_TAG}" >> $GITHUB_OUTPUT
          echo "latest_upstream_tag_sha=${LATEST_UPSTREAM_TAG_SHA}" >> $GITHUB_OUTPUT
          
          if [ -f .llama_cpp_sync_state.json ]; then
            LAST_SHA=$(cat .llama_cpp_sync_state.json | jq -r '.last_sync_sha // ""')
          else
            LAST_SHA=""
          fi
          
          # Build only for tag pushes, or manual workflow_dispatch when force_rebuild=true.
          if [ "${{ github.event.inputs.force_rebuild }}" == "true" ] || \
             [ "${REF_TYPE}" = "tag" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            echo "should_build=false" >> $GITHUB_OUTPUT
          fi

  validate-bindings:
    needs: check-upstream
    if: needs.check-upstream.outputs.should_build == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version-file: .python-version

      - name: Resolve pinned llama.cpp SHA
        id: pinned
        run: |
          python - <<'PY'
          import json, os, pathlib, re, sys

          root = pathlib.Path('.')
          sha = ''

          state = root / '.llama_cpp_sync_state.json'
          if state.exists():
              try:
                  sha = json.loads(state.read_text(encoding='utf-8')).get('last_sync_sha', '')
              except Exception:
                  sha = ''

          if not sha:
              bindings = root / 'src' / 'llama_cpp_py_sync' / '_cffi_bindings.py'
              if bindings.exists():
                  m = re.search(r"llama\.cpp commit:\s*([0-9a-fA-F]{7,40})", bindings.read_text(encoding='utf-8'))
                  if m:
                      sha = m.group(1)

          if not sha:
              print('Could not resolve pinned llama.cpp SHA', file=sys.stderr)
              sys.exit(1)

          print(f"sha={sha}")
          print(f"sha={sha}", file=open(os.environ['GITHUB_OUTPUT'], 'a'))
          PY

      - name: Resolve bindings timestamp
        id: bind_ts
        run: |
          python - <<'PY'
          import os, pathlib, re, sys

          bindings = pathlib.Path('src/llama_cpp_py_sync/_cffi_bindings.py')
          ts = ''
          if bindings.exists():
              m = re.search(r"Generated:\s*(.+)", bindings.read_text(encoding='utf-8'))
              if m:
                  ts = m.group(1).strip()

          if not ts:
              print('Could not resolve bindings timestamp', file=sys.stderr)
              sys.exit(1)

          print(f"timestamp={ts}")
          print(f"timestamp={ts}", file=open(os.environ['GITHUB_OUTPUT'], 'a'))
          PY

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install cffi numpy

      - name: Clone llama.cpp (headers only)
        run: |
          set -euo pipefail
          git clone ${{ env.LLAMA_CPP_REPO }} vendor/llama.cpp
          git -C vendor/llama.cpp fetch --depth 1 origin "${{ steps.pinned.outputs.sha }}"
          git -C vendor/llama.cpp checkout --detach "${{ steps.pinned.outputs.sha }}"

      - name: Regenerate bindings from vendored llama.cpp
        run: |
          python scripts/gen_bindings.py --commit-sha "$(git -C vendor/llama.cpp rev-parse HEAD)" --timestamp "${{ steps.bind_ts.outputs.timestamp }}"

      - name: Validate header, structs/enums, and signatures
        run: |
          python scripts/validate_cffi_surface.py --check-structs --check-enums --check-signatures

      - name: Ensure committed bindings are up-to-date
        run: |
          git diff --exit-code -- src/llama_cpp_py_sync/_cffi_bindings.py

  build-linux-x86_64:
    needs: [check-upstream, validate-bindings]
    if: needs.check-upstream.outputs.should_build == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version-file: .python-version
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build wheel cffi numpy
      
      - name: Clone llama.cpp
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $env:LLAMA_SHA = '${{ needs.check-upstream.outputs.upstream_sha }}'
          git clone ${{ env.LLAMA_CPP_REPO }} vendor/llama.cpp
          git -C vendor/llama.cpp fetch --depth 1 origin $env:LLAMA_SHA
          git -C vendor/llama.cpp checkout --detach $env:LLAMA_SHA
      
      - name: Install build tools
        run: |
          sudo apt-get update
          sudo apt-get install -y cmake ninja-build build-essential

      - name: Regenerate bindings from vendored llama.cpp
        run: |
          python scripts/gen_bindings.py --commit-sha "$(git -C vendor/llama.cpp rev-parse HEAD)"
      
      - name: Build llama.cpp
        run: |
          python scripts/build_llama_cpp.py --no-cuda --no-rocm --no-vulkan

      - name: Validate llama.cpp exports
        run: |
          python scripts/validate_llama_exports.py
      
      - name: Generate version
        run: |
          python scripts/auto_version.py --update
      
      - name: Build wheel
        run: |
          python -m build --wheel

      - name: Retag wheel (linux)
        run: |
          python -m pip install --upgrade wheel
          ORIGINAL_WHEELS=$(ls dist/*.whl)
          for w in $ORIGINAL_WHEELS; do
            python -m wheel tags --platform-tag manylinux2014_x86_64 --build 1cpu "$w"
          done
          rm -f $ORIGINAL_WHEELS
      
      - name: Upload wheel
        uses: actions/upload-artifact@v4
        with:
          name: wheel-linux-x86_64-cpu
          path: dist/*.whl

  build-linux-x86_64-cuda:
    needs: [check-upstream, validate-bindings]
    if: needs.check-upstream.outputs.should_build == 'true'
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version-file: .python-version

      - name: Install CUDA Toolkit
        uses: Jimver/cuda-toolkit@v0.2.29
        with:
          cuda: '12.2.0'
          method: 'network'

      - name: Install system dependencies
        run: |
          for i in 1 2 3 4 5; do
            sudo apt-get update && break
            echo "apt-get update failed (attempt $i/5). Sleeping before retry..."
            sleep 20
          done
          sudo apt-get install -y cmake ninja-build build-essential

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build wheel cffi numpy
      
      - name: Clone llama.cpp
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $env:LLAMA_SHA = '${{ needs.check-upstream.outputs.upstream_sha }}'
          git clone ${{ env.LLAMA_CPP_REPO }} vendor/llama.cpp
          git -C vendor/llama.cpp fetch --depth 1 origin $env:LLAMA_SHA
          git -C vendor/llama.cpp checkout --detach $env:LLAMA_SHA

      - name: Regenerate bindings from vendored llama.cpp
        run: |
          python scripts/gen_bindings.py --commit-sha "$(git -C vendor/llama.cpp rev-parse HEAD)"
      
      - name: Build llama.cpp with CUDA
        run: |
          python scripts/build_llama_cpp.py --no-rocm --no-vulkan --no-metal --parallel 2

      - name: Validate llama.cpp exports
        run: |
          python scripts/validate_llama_exports.py

      - name: Bundle llama.cpp dependency DLLs
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $packageDir = Join-Path $env:GITHUB_WORKSPACE 'src\llama_cpp_py_sync'
          $buildDir = Join-Path $env:GITHUB_WORKSPACE 'vendor\llama.cpp\build'
          if (-not (Test-Path $buildDir)) {
            Write-Host "llama.cpp build dir not found: $buildDir"
            exit 0
          }
          $depDlls = Get-ChildItem -Path $buildDir -Recurse -Filter 'ggml*.dll' -ErrorAction SilentlyContinue
          foreach ($d in $depDlls) {
            Copy-Item -Force $d.FullName $packageDir
            Write-Host "Bundled llama.cpp dep: $($d.FullName)"
          }
      
      - name: Generate version
        run: |
          python scripts/auto_version.py --update
      
      - name: Build wheel
        run: |
          python -m build --wheel

      - name: Retag wheel (linux)
        run: |
          python -m pip install --upgrade wheel
          ORIGINAL_WHEELS=$(ls dist/*.whl)
          for w in $ORIGINAL_WHEELS; do
            python -m wheel tags --platform-tag manylinux2014_x86_64 --build 1cuda "$w"
          done
          rm -f $ORIGINAL_WHEELS
      
      - name: Upload wheel
        uses: actions/upload-artifact@v4
        with:
          name: wheel-linux-x86_64-cuda
          path: dist/*.whl

  build-linux-x86_64-vulkan:
    needs: [check-upstream, validate-bindings]
    if: needs.check-upstream.outputs.should_build == 'true'
    runs-on: ubuntu-24.04
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version-file: .python-version
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build wheel cffi numpy
      
      - name: Clone llama.cpp
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $env:LLAMA_SHA = '${{ needs.check-upstream.outputs.upstream_sha }}'
          git clone ${{ env.LLAMA_CPP_REPO }} vendor/llama.cpp
          git -C vendor/llama.cpp fetch --depth 1 origin $env:LLAMA_SHA
          git -C vendor/llama.cpp checkout --detach $env:LLAMA_SHA
      
      - name: Install build tools
        run: |
          sudo apt-get update
          sudo apt-get install -y cmake ninja-build build-essential libvulkan-dev glslc glslang-tools

      - name: Regenerate bindings from vendored llama.cpp
        run: |
          python scripts/gen_bindings.py --commit-sha "$(git -C vendor/llama.cpp rev-parse HEAD)"
      
      - name: Build llama.cpp with Vulkan
        run: |
          python scripts/build_llama_cpp.py --no-cuda --no-rocm --no-metal

      - name: Validate llama.cpp exports
        run: |
          python scripts/validate_llama_exports.py
      
      - name: Generate version
        run: |
          python scripts/auto_version.py --update
      
      - name: Build wheel
        run: |
          python -m build --wheel

      - name: Retag wheel (linux)
        run: |
          python -m pip install --upgrade wheel
          ORIGINAL_WHEELS=$(ls dist/*.whl)
          for w in $ORIGINAL_WHEELS; do
            python -m wheel tags --platform-tag manylinux2014_x86_64 --build 1vulkan "$w"
          done
          rm -f $ORIGINAL_WHEELS
      
      - name: Upload wheel
        uses: actions/upload-artifact@v4
        with:
          name: wheel-linux-x86_64-vulkan
          path: dist/*.whl

  build-macos-arm64:
    needs: [check-upstream, validate-bindings]
    if: needs.check-upstream.outputs.should_build == 'true'
    runs-on: macos-14
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version-file: .python-version
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build wheel cffi numpy
      
      - name: Clone llama.cpp
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $env:LLAMA_SHA = '${{ needs.check-upstream.outputs.upstream_sha }}'
          git clone ${{ env.LLAMA_CPP_REPO }} vendor/llama.cpp
          git -C vendor/llama.cpp fetch --depth 1 origin $env:LLAMA_SHA
          git -C vendor/llama.cpp checkout --detach $env:LLAMA_SHA

      - name: Install build tools
        run: |
          brew install cmake ninja

      - name: Regenerate bindings from vendored llama.cpp
        run: |
          python scripts/gen_bindings.py --commit-sha "$(git -C vendor/llama.cpp rev-parse HEAD)"
      
      - name: Build llama.cpp with Metal
        run: |
          python scripts/build_llama_cpp.py --no-cuda --no-rocm --no-vulkan

      - name: Validate llama.cpp exports
        run: |
          python scripts/validate_llama_exports.py
      
      - name: Generate version
        run: |
          python scripts/auto_version.py --update
      
      - name: Build wheel
        run: |
          python -m build --wheel

      - name: Retag wheel (macos)
        run: |
          python -m pip install --upgrade wheel
          ORIGINAL_WHEELS=$(ls dist/*.whl)
          for w in $ORIGINAL_WHEELS; do
            python -m wheel tags --platform-tag macosx_14_0_arm64 --build 1metal "$w"
          done
          rm -f $ORIGINAL_WHEELS
      
      - name: Upload wheel
        uses: actions/upload-artifact@v4
        with:
          name: wheel-macos-arm64-metal
          path: dist/*.whl

  build-macos-x86_64:
    needs: [check-upstream, validate-bindings]
    if: needs.check-upstream.outputs.should_build == 'true'
    runs-on: macos-15-intel
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version-file: .python-version
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build wheel cffi numpy
      
      - name: Clone llama.cpp
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $env:LLAMA_SHA = '${{ needs.check-upstream.outputs.upstream_sha }}'
          git clone ${{ env.LLAMA_CPP_REPO }} vendor/llama.cpp
          git -C vendor/llama.cpp fetch --depth 1 origin $env:LLAMA_SHA
          git -C vendor/llama.cpp checkout --detach $env:LLAMA_SHA

      - name: Install build tools
        run: |
          brew install cmake ninja

      - name: Regenerate bindings from vendored llama.cpp
        run: |
          python scripts/gen_bindings.py --commit-sha "$(git -C vendor/llama.cpp rev-parse HEAD)"
      
      - name: Build llama.cpp
        run: |
          python scripts/build_llama_cpp.py --no-cuda --no-rocm --no-vulkan --no-metal

      - name: Validate llama.cpp exports
        run: |
          python scripts/validate_llama_exports.py

      - name: Bundle llama.cpp dependency DLLs
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $packageDir = Join-Path $env:GITHUB_WORKSPACE 'src\llama_cpp_py_sync'
          $buildDir = Join-Path $env:GITHUB_WORKSPACE 'vendor\llama.cpp\build'
          if (-not (Test-Path $buildDir)) {
            Write-Host "llama.cpp build dir not found: $buildDir"
            exit 0
          }
          $depDlls = Get-ChildItem -Path $buildDir -Recurse -Filter 'ggml*.dll' -ErrorAction SilentlyContinue
          foreach ($d in $depDlls) {
            Copy-Item -Force $d.FullName $packageDir
            Write-Host "Bundled llama.cpp dep: $($d.FullName)"
          }
      
      - name: Generate version
        run: |
          python scripts/auto_version.py --update
      
      - name: Build wheel
        run: |
          python -m build --wheel

      - name: Retag wheel (macos)
        run: |
          python -m pip install --upgrade wheel
          ORIGINAL_WHEELS=$(ls dist/*.whl)
          for w in $ORIGINAL_WHEELS; do
            python -m wheel tags --platform-tag macosx_14_0_x86_64 --build 1cpu "$w"
          done
          rm -f $ORIGINAL_WHEELS
      
      - name: Upload wheel
        uses: actions/upload-artifact@v4
        with:
          name: wheel-macos-x86_64-cpu
          path: dist/*.whl

  build-windows-x64:
    needs: [check-upstream, validate-bindings]
    if: needs.check-upstream.outputs.should_build == 'true'
    runs-on: windows-2022
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version-file: .python-version

      - name: Set up MSVC dev environment
        uses: ilammy/msvc-dev-cmd@v1
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build wheel cffi numpy
      
      - name: Clone llama.cpp
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $env:LLAMA_SHA = '${{ needs.check-upstream.outputs.upstream_sha }}'
          git clone ${{ env.LLAMA_CPP_REPO }} vendor/llama.cpp
          git -C vendor/llama.cpp fetch --depth 1 origin $env:LLAMA_SHA
          git -C vendor/llama.cpp checkout --detach $env:LLAMA_SHA

      - name: Install Ninja
        shell: pwsh
        run: |
          choco install ninja -y

      - name: Regenerate bindings from vendored llama.cpp
        shell: pwsh
        run: |
          $sha = git -C vendor/llama.cpp rev-parse HEAD
          python scripts/gen_bindings.py --commit-sha $sha
      
      - name: Build llama.cpp
        run: |
          python scripts/build_llama_cpp.py --no-cuda --no-rocm --no-vulkan --no-metal

      - name: Validate llama.cpp exports
        run: |
          python scripts/validate_llama_exports.py

      - name: Bundle Windows runtime DLLs
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $packageDir = Join-Path $env:GITHUB_WORKSPACE 'src\llama_cpp_py_sync'
          New-Item -ItemType Directory -Force -Path $packageDir | Out-Null

          $requiredDlls = @(
            # MSVC / OpenMP runtime
            'vcruntime140.dll',
            'vcruntime140_1.dll',
            'msvcp140.dll',
            'concrt140.dll',
            'vcomp140.dll',

            # CUDA runtime (optional - only bundled if found)
            'cudart64_12.dll',
            'cublas64_12.dll',
            'cublasLt64_12.dll',
            'cudnn64_8.dll',
            'nvrtc64_120_0.dll',

            # Vulkan loader (optional - only bundled if found)
            'vulkan-1.dll'
          )

          function Copy-DllIfFound([string]$path) {
            if (Test-Path $path) {
              Copy-Item -Force $path $packageDir
              Write-Host "Bundled: $path"
              return $true
            }
            return $false
          }

          $searchDirs = @()

          # 1) VS redist via environment variable when available
          if ($env:VCToolsRedistDir) {
            $searchDirs += (Join-Path $env:VCToolsRedistDir 'x64\Microsoft.VC143.CRT')
            $searchDirs += (Join-Path $env:VCToolsRedistDir 'x64')
          }

          # 2) Common Visual Studio Redist locations
          $pf86 = ${env:ProgramFiles(x86)}
          if (-not $pf86) { $pf86 = 'C:\\Program Files (x86)' }
          $vsRoot = Join-Path $pf86 'Microsoft Visual Studio'
          if (Test-Path $vsRoot) {
            $candidates = Get-ChildItem -Path $vsRoot -Recurse -Directory -ErrorAction SilentlyContinue |
              Where-Object { $_.FullName -match '\\VC\\Redist\\MSVC\\' -and $_.FullName -match '\\x64(\\Microsoft\.VC\d+\.CRT)?$' }
            foreach ($dir in $candidates) {
              $searchDirs += $dir.FullName
            }
          }

          # 3) System folders
          $searchDirs += (Join-Path $env:WINDIR 'System32')
          $searchDirs += (Join-Path $env:WINDIR 'SysWOW64')

          # 4) CUDA paths (prefer env CUDA_PATH)
          if ($env:CUDA_PATH -and (Test-Path $env:CUDA_PATH)) {
            $searchDirs += (Join-Path $env:CUDA_PATH 'bin')
            $searchDirs += (Join-Path $env:CUDA_PATH 'lib')
          }
          $searchDirs += 'C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.4\\bin'
          $searchDirs += 'C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.4\\lib'
          $searchDirs += 'C:\\Program Files\\NVIDIA Corporation\\NvToolsExt\\bin\\x64'

          # 5) Vulkan paths (prefer env VULKAN_SDK)
          if ($env:VULKAN_SDK -and (Test-Path $env:VULKAN_SDK)) {
            $searchDirs += (Join-Path $env:VULKAN_SDK 'Bin')
            $searchDirs += (Join-Path $env:VULKAN_SDK 'Lib')
          }
          $searchDirs += 'C:\\VulkanSDK\\1.4.335.0\\Bin'
          $searchDirs += 'C:\\VulkanSDK\\1.4.335.0\\Lib'

          # Normalize + unique existing dirs
          $searchDirs = $searchDirs | Where-Object { $_ -and (Test-Path $_) } | Select-Object -Unique

          $found = @{}
          foreach ($n in $requiredDlls) { $found[$n] = $false }

          foreach ($n in $requiredDlls) {
            foreach ($dir in $searchDirs) {
              if (-not $found[$n]) {
                $found[$n] = Copy-DllIfFound (Join-Path $dir $n)
              }
            }
          }

          $missing = @()
          foreach ($n in $requiredDlls) { if (-not $found[$n]) { $missing += $n } }
          if ($missing.Count -gt 0) {
            Write-Warning "Some runtime DLLs were not found and could not be bundled (this is expected if CUDA/Vulkan SDKs are not installed on the runner): $($missing -join ', ')"
          }
      
      - name: Generate version
        run: |
          python scripts/auto_version.py --update
      
      - name: Build wheel
        run: |
          python -m build --wheel

      - name: Retag wheel (windows)
        shell: pwsh
        run: |
          python -m pip install --upgrade wheel
          $wheels = Get-ChildItem -Path dist -Filter *.whl
          if (-not $wheels) { throw "No wheels found in dist/" }
          foreach ($w in $wheels) {
            python -m wheel tags --platform-tag win_amd64 --build 1cpu $w.FullName
          }
          foreach ($w in $wheels) { Remove-Item -Force $w.FullName }
      
      - name: Upload wheel
        uses: actions/upload-artifact@v4
        with:
          name: wheel-windows-x64-cpu
          path: dist/*win_amd64.whl

  build-windows-x64-cuda:
    needs: [check-upstream, validate-bindings]
    if: needs.check-upstream.outputs.should_build == 'true'
    runs-on: windows-2022
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version-file: .python-version

      - name: Set up MSVC dev environment
        uses: ilammy/msvc-dev-cmd@v1

      - name: Install CUDA Toolkit
        uses: Jimver/cuda-toolkit@v0.2.29
        with:
          cuda: '12.4.1'
          method: 'network'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build wheel cffi numpy
      
      - name: Clone llama.cpp
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $env:LLAMA_SHA = '${{ needs.check-upstream.outputs.upstream_sha }}'
          git clone ${{ env.LLAMA_CPP_REPO }} vendor/llama.cpp
          git -C vendor/llama.cpp fetch --depth 1 origin $env:LLAMA_SHA
          git -C vendor/llama.cpp checkout --detach $env:LLAMA_SHA

      - name: Install Ninja
        shell: pwsh
        run: |
          choco install ninja -y

      - name: Regenerate bindings from vendored llama.cpp
        shell: pwsh
        run: |
          $sha = git -C vendor/llama.cpp rev-parse HEAD
          python scripts/gen_bindings.py --commit-sha $sha
      
      - name: Build llama.cpp with CUDA
        run: |
          python scripts/build_llama_cpp.py --no-rocm --no-vulkan --no-metal --parallel 2

      - name: Bundle Windows runtime DLLs
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $packageDir = Join-Path $env:GITHUB_WORKSPACE 'src\llama_cpp_py_sync'
          New-Item -ItemType Directory -Force -Path $packageDir | Out-Null

          $requiredDlls = @(
            # MSVC / OpenMP runtime
            'vcruntime140.dll',
            'vcruntime140_1.dll',
            'msvcp140.dll',
            'concrt140.dll',
            'vcomp140.dll',

            # CUDA runtime
            'cudart64_12.dll',
            'cublas64_12.dll',
            'cublasLt64_12.dll',
            'cudnn64_8.dll',
            'nvrtc64_120_0.dll'
          )

          function Copy-DllIfFound([string]$path) {
            if (Test-Path $path) {
              Copy-Item -Force $path $packageDir
              Write-Host "Bundled: $path"
              return $true
            }
            return $false
          }

          $searchDirs = @()

          if ($env:VCToolsRedistDir) {
            $searchDirs += (Join-Path $env:VCToolsRedistDir 'x64\Microsoft.VC143.CRT')
            $searchDirs += (Join-Path $env:VCToolsRedistDir 'x64')
          }

          $pf86 = ${env:ProgramFiles(x86)}
          if (-not $pf86) { $pf86 = 'C:\\Program Files (x86)' }
          $vsRoot = Join-Path $pf86 'Microsoft Visual Studio'
          if (Test-Path $vsRoot) {
            $candidates = Get-ChildItem -Path $vsRoot -Recurse -Directory -ErrorAction SilentlyContinue |
              Where-Object { $_.FullName -match '\\VC\\Redist\\MSVC\\' -and $_.FullName -match '\\x64(\\Microsoft\.VC\d+\.CRT)?$' }
            foreach ($dir in $candidates) {
              $searchDirs += $dir.FullName
            }
          }

          $searchDirs += (Join-Path $env:WINDIR 'System32')
          $searchDirs += (Join-Path $env:WINDIR 'SysWOW64')

          if ($env:CUDA_PATH -and (Test-Path $env:CUDA_PATH)) {
            $searchDirs += (Join-Path $env:CUDA_PATH 'bin')
            $searchDirs += (Join-Path $env:CUDA_PATH 'lib')
          }
          $searchDirs += 'C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.4\\bin'
          $searchDirs += 'C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.4\\lib'
          $searchDirs += 'C:\\Program Files\\NVIDIA Corporation\\NvToolsExt\\bin\\x64'

          $searchDirs = $searchDirs | Where-Object { $_ -and (Test-Path $_) } | Select-Object -Unique

          $found = @{}
          foreach ($n in $requiredDlls) { $found[$n] = $false }

          foreach ($n in $requiredDlls) {
            foreach ($dir in $searchDirs) {
              if (-not $found[$n]) {
                $found[$n] = Copy-DllIfFound (Join-Path $dir $n)
              }
            }
          }

          $missing = @()
          foreach ($n in $requiredDlls) { if (-not $found[$n]) { $missing += $n } }
          if ($missing.Count -gt 0) {
            Write-Warning "Some runtime DLLs were not found and could not be bundled: $($missing -join ', ')"
          }

      - name: Validate llama.cpp exports
        run: |
          python scripts/validate_llama_exports.py
      
      - name: Generate version
        run: |
          python scripts/auto_version.py --update
      
      - name: Build wheel
        run: |
          python -m build --wheel

      - name: Retag wheel (windows)
        shell: pwsh
        run: |
          python -m pip install --upgrade wheel
          $wheels = Get-ChildItem -Path dist -Filter *.whl
          if (-not $wheels) { throw "No wheels found in dist/" }
          foreach ($w in $wheels) {
            python -m wheel tags --platform-tag win_amd64 --build 1cuda $w.FullName
          }
          foreach ($w in $wheels) { Remove-Item -Force $w.FullName }
      
      - name: Upload wheel
        uses: actions/upload-artifact@v4
        with:
          name: wheel-windows-x64-cuda
          path: dist/*win_amd64.whl

  build-windows-x64-vulkan:
    needs: [check-upstream, validate-bindings]
    if: needs.check-upstream.outputs.should_build == 'true'
    runs-on: windows-2022
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version-file: .python-version

      - name: Set up MSVC dev environment
        uses: ilammy/msvc-dev-cmd@v1

      - name: Install Vulkan SDK
        uses: jakoch/install-vulkan-sdk-action@v1
        with:
          vulkan_version: '1.4.335.0'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build wheel cffi numpy
      
      - name: Clone llama.cpp
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $env:LLAMA_SHA = '${{ needs.check-upstream.outputs.upstream_sha }}'
          git clone ${{ env.LLAMA_CPP_REPO }} vendor/llama.cpp
          git -C vendor/llama.cpp fetch --depth 1 origin $env:LLAMA_SHA
          git -C vendor/llama.cpp checkout --detach $env:LLAMA_SHA

      - name: Install Ninja
        shell: pwsh
        run: |
          choco install ninja -y

      - name: Regenerate bindings from vendored llama.cpp
        shell: pwsh
        run: |
          $sha = git -C vendor/llama.cpp rev-parse HEAD
          python scripts/gen_bindings.py --commit-sha $sha
      
      - name: Build llama.cpp with Vulkan
        run: |
          python scripts/build_llama_cpp.py --no-cuda --no-rocm --no-metal

      - name: Validate llama.cpp exports
        run: |
          python scripts/validate_llama_exports.py

      - name: Bundle Windows runtime DLLs
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $packageDir = Join-Path $env:GITHUB_WORKSPACE 'src\llama_cpp_py_sync'
          New-Item -ItemType Directory -Force -Path $packageDir | Out-Null

          $requiredDlls = @(
            # MSVC runtime (OpenMP might not be used for Vulkan builds but bundling is harmless)
            'vcruntime140.dll',
            'vcruntime140_1.dll',
            'msvcp140.dll',
            'concrt140.dll',
            'vcomp140.dll',
            # Vulkan loader
            'vulkan-1.dll'
          )

          function Copy-DllIfFound([string]$path) {
            if (Test-Path $path) {
              Copy-Item -Force $path $packageDir
              Write-Host "Bundled: $path"
              return $true
            }
            return $false
          }

          $searchDirs = @()

          if ($env:VCToolsRedistDir) {
            $searchDirs += (Join-Path $env:VCToolsRedistDir 'x64\Microsoft.VC143.CRT')
            $searchDirs += (Join-Path $env:VCToolsRedistDir 'x64')
          }

          $pf86 = ${env:ProgramFiles(x86)}
          if (-not $pf86) { $pf86 = 'C:\\Program Files (x86)' }
          $vsRoot = Join-Path $pf86 'Microsoft Visual Studio'
          if (Test-Path $vsRoot) {
            $candidates = Get-ChildItem -Path $vsRoot -Recurse -Directory -ErrorAction SilentlyContinue |
              Where-Object { $_.FullName -match '\\VC\\Redist\\MSVC\\' -and $_.FullName -match '\\x64(\\Microsoft\.VC\d+\.CRT)?$' }
            foreach ($dir in $candidates) {
              $searchDirs += $dir.FullName
            }
          }

          $searchDirs += (Join-Path $env:WINDIR 'System32')
          $searchDirs += (Join-Path $env:WINDIR 'SysWOW64')

          if ($env:VULKAN_SDK -and (Test-Path $env:VULKAN_SDK)) {
            $searchDirs += (Join-Path $env:VULKAN_SDK 'Bin')
            $searchDirs += (Join-Path $env:VULKAN_SDK 'Lib')
          }
          $searchDirs += 'C:\\VulkanSDK\\1.4.335.0\\Bin'
          $searchDirs += 'C:\\VulkanSDK\\1.4.335.0\\Lib'

          $searchDirs = $searchDirs | Where-Object { $_ -and (Test-Path $_) } | Select-Object -Unique

          $found = @{}
          foreach ($n in $requiredDlls) { $found[$n] = $false }

          foreach ($n in $requiredDlls) {
            foreach ($dir in $searchDirs) {
              if (-not $found[$n]) {
                $found[$n] = Copy-DllIfFound (Join-Path $dir $n)
              }
            }
          }

          $missing = @()
          foreach ($n in $requiredDlls) { if (-not $found[$n]) { $missing += $n } }
          if ($missing.Count -gt 0) {
            Write-Warning "Some runtime DLLs were not found and could not be bundled: $($missing -join ', ')"
          }
      
      - name: Generate version
        run: |
          python scripts/auto_version.py --update
      
      - name: Build wheel
        run: |
          python -m build --wheel

      - name: Retag wheel (windows)
        shell: pwsh
        run: |
          python -m pip install --upgrade wheel
          $wheels = Get-ChildItem -Path dist -Filter *.whl
          if (-not $wheels) { throw "No wheels found in dist/" }
          foreach ($w in $wheels) {
            python -m wheel tags --platform-tag win_amd64 --build 1vulkan $w.FullName
          }
          foreach ($w in $wheels) { Remove-Item -Force $w.FullName }
      
      - name: Upload wheel
        uses: actions/upload-artifact@v4
        with:
          name: wheel-windows-x64-vulkan
          path: dist/*win_amd64.whl

  release:
    needs: [check-upstream, build-linux-x86_64, build-linux-x86_64-cuda, build-linux-x86_64-vulkan, build-macos-arm64, build-macos-x86_64, build-windows-x64, build-windows-x64-cuda, build-windows-x64-vulkan]
    if: (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && startsWith(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
      
      - name: Download all wheels
        uses: actions/download-artifact@v4
        with:
          path: dist
          pattern: wheel-*
          merge-multiple: true

      - name: Download CPU-only wheels (for PyPI)
        uses: actions/download-artifact@v4
        with:
          path: dist_pypi
          pattern: wheel-*-cpu
          merge-multiple: true

      - name: Download macOS Metal wheels (for PyPI)
        uses: actions/download-artifact@v4
        with:
          path: dist_pypi
          pattern: wheel-macos-arm64-metal
          merge-multiple: true
      
      - name: Create Release
        uses: softprops/action-gh-release@v1
        if: startsWith(github.ref, 'refs/tags/') && needs.check-upstream.outputs.upstream_tag_exists == 'true'
        with:
          files: dist/*.whl
          generate_release_notes: true
      
      - name: Publish to PyPI
        if: startsWith(github.ref, 'refs/tags/') && needs.check-upstream.outputs.upstream_tag_exists == 'true' && env.PYPI_API_TOKEN != ''
        env:
          PYPI_API_TOKEN: ${{ secrets.PYPI_API_TOKEN }}
        run: |
          python -m pip install --upgrade pip
          python -m pip install --upgrade packaging twine
          twine upload dist_pypi/*.whl -u __token__ -p $PYPI_API_TOKEN
